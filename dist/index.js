import * as __WEBPACK_EXTERNAL_MODULE__script_js_588e7203__ from "../../../../../script.js";
import * as __WEBPACK_EXTERNAL_MODULE__authors_note_js_59167e8d__ from "../../../../authors-note.js";
import * as __WEBPACK_EXTERNAL_MODULE__chats_js_c244506c__ from "../../../../chats.js";
import * as __WEBPACK_EXTERNAL_MODULE__group_chats_js_678c16bd__ from "../../../../group-chats.js";
import * as __WEBPACK_EXTERNAL_MODULE__instruct_mode_js_e7f3531a__ from "../../../../instruct-mode.js";
import * as __WEBPACK_EXTERNAL_MODULE__openai_js_bf183548__ from "../../../../openai.js";
import * as __WEBPACK_EXTERNAL_MODULE__power_user_js_3c7cfb8b__ from "../../../../power-user.js";
import * as __WEBPACK_EXTERNAL_MODULE__world_info_js_83198f57__ from "../../../../world-info.js";
import * as __WEBPACK_EXTERNAL_MODULE__regex_engine_js_683beba0__ from "../../../regex/engine.js";
/******/ var __webpack_modules__ = ({

/***/ "../../../../../script.js":
/*!*******************************************!*\
  !*** external "../../../../../script.js" ***!
  \*******************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__script_js_588e7203__;

/***/ }),

/***/ "../../../../authors-note.js":
/*!**********************************************!*\
  !*** external "../../../../authors-note.js" ***!
  \**********************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__authors_note_js_59167e8d__;

/***/ }),

/***/ "../../../../chats.js":
/*!***************************************!*\
  !*** external "../../../../chats.js" ***!
  \***************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__chats_js_c244506c__;

/***/ }),

/***/ "../../../../group-chats.js":
/*!*********************************************!*\
  !*** external "../../../../group-chats.js" ***!
  \*********************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__group_chats_js_678c16bd__;

/***/ }),

/***/ "../../../../instruct-mode.js":
/*!***********************************************!*\
  !*** external "../../../../instruct-mode.js" ***!
  \***********************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__instruct_mode_js_e7f3531a__;

/***/ }),

/***/ "../../../../openai.js":
/*!****************************************!*\
  !*** external "../../../../openai.js" ***!
  \****************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__openai_js_bf183548__;

/***/ }),

/***/ "../../../../power-user.js":
/*!********************************************!*\
  !*** external "../../../../power-user.js" ***!
  \********************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__power_user_js_3c7cfb8b__;

/***/ }),

/***/ "../../../../world-info.js":
/*!********************************************!*\
  !*** external "../../../../world-info.js" ***!
  \********************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__world_info_js_83198f57__;

/***/ }),

/***/ "../../../regex/engine.js":
/*!*******************************************!*\
  !*** external "../../../regex/engine.js" ***!
  \*******************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__regex_engine_js_683beba0__;

/***/ }),

/***/ "./node_modules/sillytavern-utils-lib/dist/config.js":
/*!***********************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/config.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   characters: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.characters),
/* harmony export */   depth_prompt_depth_default: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.depth_prompt_depth_default),
/* harmony export */   depth_prompt_role_default: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.depth_prompt_role_default),
/* harmony export */   extension_prompt_types: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.extension_prompt_types),
/* harmony export */   main_api: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.main_api),
/* harmony export */   name1: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.name1),
/* harmony export */   name2: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.name2),
/* harmony export */   persona_description_positions: () => (/* reexport safe */ _power_user_js__WEBPACK_IMPORTED_MODULE_0__.persona_description_positions),
/* harmony export */   regex_placement: () => (/* reexport safe */ _regex_engine_js__WEBPACK_IMPORTED_MODULE_8__.regex_placement),
/* harmony export */   selected_group: () => (/* reexport safe */ _group_chats_js__WEBPACK_IMPORTED_MODULE_7__.selected_group),
/* harmony export */   st_appendFileContent: () => (/* binding */ st_appendFileContent),
/* harmony export */   st_baseChatReplace: () => (/* binding */ st_baseChatReplace),
/* harmony export */   st_echo: () => (/* binding */ st_echo),
/* harmony export */   st_formatInstructModeExamples: () => (/* binding */ st_formatInstructModeExamples),
/* harmony export */   st_formatInstructModeSystemPrompt: () => (/* binding */ st_formatInstructModeSystemPrompt),
/* harmony export */   st_formatWorldInfo: () => (/* binding */ st_formatWorldInfo),
/* harmony export */   st_getAuthorNote: () => (/* binding */ st_getAuthorNote),
/* harmony export */   st_getGroupDepthPrompts: () => (/* binding */ st_getGroupDepthPrompts),
/* harmony export */   st_getMaxContextSize: () => (/* binding */ st_getMaxContextSize),
/* harmony export */   st_getPromptPosition: () => (/* binding */ st_getPromptPosition),
/* harmony export */   st_getPromptRole: () => (/* binding */ st_getPromptRole),
/* harmony export */   st_getRegexedString: () => (/* binding */ st_getRegexedString),
/* harmony export */   st_parseMesExamples: () => (/* binding */ st_parseMesExamples),
/* harmony export */   st_prepareOpenAIMessages: () => (/* binding */ st_prepareOpenAIMessages),
/* harmony export */   st_renderStoryString: () => (/* binding */ st_renderStoryString),
/* harmony export */   st_runCommandCallback: () => (/* binding */ st_runCommandCallback),
/* harmony export */   st_setOpenAIMessageExamples: () => (/* binding */ st_setOpenAIMessageExamples),
/* harmony export */   st_setOpenAIMessages: () => (/* binding */ st_setOpenAIMessages),
/* harmony export */   systemUserName: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.systemUserName),
/* harmony export */   system_avatar: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.system_avatar),
/* harmony export */   this_chid: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.this_chid),
/* harmony export */   wi_anchor_position: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.wi_anchor_position),
/* harmony export */   world_info_include_names: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.world_info_include_names)
/* harmony export */ });
/* harmony import */ var _power_user_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../power-user.js */ "../../../../power-user.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../script.js */ "../../../../../script.js");
/* harmony import */ var _world_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../world-info.js */ "../../../../world-info.js");
/* harmony import */ var _instruct_mode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../instruct-mode.js */ "../../../../instruct-mode.js");
/* harmony import */ var _chats_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../chats.js */ "../../../../chats.js");
/* harmony import */ var _openai_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../openai.js */ "../../../../openai.js");
/* harmony import */ var _authors_note_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../authors-note.js */ "../../../../authors-note.js");
/* harmony import */ var _group_chats_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../group-chats.js */ "../../../../group-chats.js");
/* harmony import */ var _regex_engine_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../regex/engine.js */ "../../../regex/engine.js");
// @ts-ignore


// @ts-ignore

// @ts-ignore

// @ts-ignore


// @ts-ignore

// @ts-ignore

// @ts-ignore

async function st_runCommandCallback(command, ...args) {
    // @ts-ignore
    await SillyTavern.getContext().SlashCommandParser.commands[command].callback(...args);
}
/**
 * Sends an echo message using the SlashCommandParser's echo command.
 */
async function st_echo(severity, message) {
    await st_runCommandCallback('echo', { severity: severity }, message);
}
function st_getMaxContextSize(overrideResponseLength) {
    return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.getMaxContextSize)(overrideResponseLength);
}
function st_parseMesExamples(examplesStr, isInstruct) {
    return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.parseMesExamples)(examplesStr, isInstruct);
}
function st_baseChatReplace(value, name1, name2) {
    return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.baseChatReplace)(value, name1, name2);
}
function st_formatInstructModeExamples(mesExamplesArray, name1, name2) {
    return (0,_instruct_mode_js__WEBPACK_IMPORTED_MODULE_3__.formatInstructModeExamples)(mesExamplesArray, name1, name2);
}
function st_formatInstructModeSystemPrompt(systemPrompt, customInstruct) {
    return (0,_instruct_mode_js__WEBPACK_IMPORTED_MODULE_3__.formatInstructModeSystemPrompt)(systemPrompt, customInstruct);
}
function st_renderStoryString(params, { customStoryString, customInstructSettings, } = {}) {
    return (0,_power_user_js__WEBPACK_IMPORTED_MODULE_0__.renderStoryString)(params, { customStoryString, customInstructSettings });
}
function st_getPromptRole(role) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.getPromptRole)(role);
}
function st_getAuthorNote() {
    return {
        prompt: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_6__.metadata_keys.prompt],
        interval: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_6__.metadata_keys.interval],
        position: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_6__.metadata_keys.position],
        depth: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_6__.metadata_keys.depth],
        role: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_6__.metadata_keys.role],
    };
}
function st_getGroupDepthPrompts(groupId, characterId) {
    return (0,_group_chats_js__WEBPACK_IMPORTED_MODULE_7__.getGroupDepthPrompts)(groupId, characterId);
}
function st_prepareOpenAIMessages({ name2, charDescription, charPersonality, Scenario, worldInfoBefore, worldInfoAfter, bias, type, quietPrompt, quietImage, extensionPrompts, cyclePrompt, systemPromptOverride, jailbreakPromptOverride, personaDescription, messages, messageExamples, }, dryRun) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.prepareOpenAIMessages)({
        name2,
        charDescription,
        charPersonality,
        Scenario,
        worldInfoBefore,
        worldInfoAfter,
        bias,
        type,
        quietPrompt,
        quietImage,
        cyclePrompt,
        systemPromptOverride,
        jailbreakPromptOverride,
        personaDescription,
        extensionPrompts,
        messages,
        messageExamples,
    }, dryRun);
}
function st_setOpenAIMessages(chat) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.setOpenAIMessages)(chat);
}
function st_setOpenAIMessageExamples(mesExamplesArray) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.setOpenAIMessageExamples)(mesExamplesArray);
}
function st_getRegexedString(rawString, placement, { characterOverride, isMarkdown, isPrompt, isEdit, depth, }) {
    return (0,_regex_engine_js__WEBPACK_IMPORTED_MODULE_8__.getRegexedString)(rawString, placement, { characterOverride, isMarkdown, isPrompt, isEdit, depth });
}
async function st_appendFileContent(message, messageText) {
    return await (0,_chats_js__WEBPACK_IMPORTED_MODULE_4__.appendFileContent)(message, messageText);
}
function st_formatWorldInfo(value, { wiFormat, } = {}) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.formatWorldInfo)(value, { wiFormat });
}
function st_getPromptPosition(position) {
    return (0,_openai_js__WEBPACK_IMPORTED_MODULE_5__.getPromptPosition)(position);
}

//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/sillytavern-utils-lib/dist/preset-select.js":
/*!******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/preset-select.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPresetSelect: () => (/* binding */ buildPresetSelect)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/sillytavern-utils-lib/dist/config.js");

function buildPresetSelect(selector, options = {}) {
    const context = SillyTavern.getContext();
    const readOnlyValues = options.readOnlyValues || [];
    const select = document.querySelector(selector);
    if (!select) {
        throw new Error(`Could not find preset select: ${selector}`);
    }
    const label = options.label || 'preset';
    const container = document.createElement('div');
    container.className = 'preset-select-container';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    const isReadOnly = (value) => {
        return readOnlyValues.includes(value);
    };
    // Wrap the select in the container
    select.parentNode?.insertBefore(container, select);
    container.appendChild(select);
    // Add initial options if provided
    if (options.initialList && options.initialList.length > 0) {
        // Clear existing options first
        select.innerHTML = '';
        // Add new options from the list
        for (const item of options.initialList) {
            const option = document.createElement('option');
            option.value = item;
            option.textContent = item;
            if (isReadOnly(item)) {
                option.dataset.readonly = 'true';
            }
            select.appendChild(option);
        }
    }
    // Set initial value if provided
    if (options.initialValue) {
        // Find option with matching value or text content
        const option = Array.from(select.options).find((opt) => opt.value === options.initialValue || opt.textContent === options.initialValue);
        if (option) {
            select.value = option.value;
        }
    }
    // Track previous value for onSelectChange
    let previousValue = select.value;
    // Set up change event handler for the select
    select.addEventListener('change', async () => {
        const newValue = select.value;
        if (options.onSelectChange && previousValue !== newValue) {
            await options.onSelectChange(previousValue, newValue);
        }
        previousValue = newValue;
    });
    // Add Create button if enabled
    if (options.create) {
        const createButton = document.createElement('i');
        createButton.className = 'menu_button fa-solid fa-file-circle-plus';
        createButton.title = `Create a new ${label}`;
        createButton.setAttribute('data-i18n', `[title]Create a new ${label}`);
        createButton.addEventListener('click', async () => {
            if (options.create?.onPopupOpen) {
                await options.create.onPopupOpen();
            }
            const newValue = await context.Popup.show.input(`Create a new ${label}`, `Please enter a name for the new ${label}:`, '');
            if (newValue === null || newValue.trim() === '')
                return;
            const trimmedValue = newValue.trim();
            // Check if a preset with this name already exists
            const exists = Array.from(select.options).some((option) => option.textContent === trimmedValue);
            if (exists) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `A ${label} with this name already exists.`);
                return;
            }
            // Run before create hook
            if (options.create?.onBeforeCreate) {
                const shouldProceed = await options.create.onBeforeCreate(trimmedValue);
                if (!shouldProceed)
                    return;
            }
            // Create new option
            const newOption = document.createElement('option');
            newOption.value = trimmedValue;
            newOption.textContent = trimmedValue;
            select.appendChild(newOption);
            // Select the new option
            select.value = trimmedValue;
            // Run after create hook
            if (options.create?.onAfterCreate) {
                await options.create.onAfterCreate(trimmedValue);
            }
            // Store previous value before changing
            const prevValue = select.value;
            // Trigger onSelectChange if the value actually changed
            if (options.onSelectChange && prevValue !== trimmedValue) {
                await options.onSelectChange(prevValue, trimmedValue);
            }
            previousValue = trimmedValue;
        });
        container.appendChild(createButton);
    }
    // Add Rename button if enabled
    if (options.rename) {
        const renameButton = document.createElement('i');
        renameButton.className = 'menu_button fa-solid fa-pencil';
        renameButton.title = `Rename a ${label}`;
        renameButton.setAttribute('data-i18n', `[title]Rename a ${label}`);
        renameButton.addEventListener('click', async () => {
            if (select.selectedIndex === -1) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `Please select a ${label} to rename.`);
                return;
            }
            const selectedOption = select.options[select.selectedIndex];
            let selectedValue = selectedOption.value;
            // Check if the selected value is read-only
            if (isReadOnly(selectedValue)) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `This ${label} cannot be renamed as it is read-only.`);
                return;
            }
            if (options.rename?.onPopupOpen) {
                await options.rename.onPopupOpen();
            }
            const newValue = await context.Popup.show.input(`Rename ${label}`, `Please enter a new name for "${selectedValue}":`, selectedValue);
            if (newValue === null || newValue.trim() === '' || newValue === selectedValue)
                return;
            const trimmedValue = newValue.trim();
            // Check if a preset with this name already exists
            const exists = Array.from(select.options).some((option) => option.textContent === trimmedValue && option !== selectedOption);
            if (exists) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `A ${label} with this name already exists.`);
                return;
            }
            // Run before rename hook
            if (options.rename?.onBeforeRename) {
                const shouldProceed = await options.rename.onBeforeRename(selectedValue, trimmedValue);
                if (!shouldProceed)
                    return;
            }
            // Rename the option
            selectedOption.value = trimmedValue;
            selectedOption.textContent = trimmedValue;
            // Update the previous value tracker
            if (selectedValue === previousValue) {
                previousValue = trimmedValue;
            }
            // Run after rename hook
            if (options.rename?.onAfterRename) {
                await options.rename.onAfterRename(selectedValue, trimmedValue);
            }
            // Trigger onSelectChange since the currently selected option changed its value
            if (options.onSelectChange && select.value === trimmedValue) {
                await options.onSelectChange(selectedValue, trimmedValue);
            }
        });
        container.appendChild(renameButton);
    }
    // Add Delete button if enabled
    if (options.delete) {
        const deleteButton = document.createElement('i');
        deleteButton.className = 'menu_button fa-solid fa-trash-can';
        deleteButton.title = `Delete a ${label}`;
        deleteButton.setAttribute('data-i18n', `[title]Delete a ${label}`);
        deleteButton.addEventListener('click', async () => {
            if (select.selectedIndex === -1) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `Please select a ${label} to delete.`);
                return;
            }
            const selectedOption = select.options[select.selectedIndex];
            const valueToDelete = selectedOption.value;
            const selectedIndex = select.selectedIndex;
            // Check if the selected value is read-only
            if (isReadOnly(valueToDelete)) {
                await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)('warning', `This ${label} cannot be deleted as it is read-only.`);
                return;
            }
            if (options.delete?.onPopupOpen) {
                await options.delete.onPopupOpen();
            }
            const confirmed = await context.Popup.show.confirm(`Are you sure you want to delete "${valueToDelete}"?`, `Delete ${label}`);
            if (!confirmed)
                return;
            // Run before delete hook
            if (options.delete?.onBeforeDelete) {
                const shouldProceed = await options.delete.onBeforeDelete(valueToDelete);
                if (!shouldProceed)
                    return;
            }
            // Store the value to delete for later reference
            const deletedValue = valueToDelete;
            // Determine the next option to select after deletion
            let nextSelectedIndex = -1;
            let nextValue = undefined;
            if (select.options.length > 1) {
                // Try to select the next option, or the previous if we're at the end
                nextSelectedIndex = selectedIndex < select.options.length - 1 ? selectedIndex : selectedIndex - 1;
                nextValue = select.options[nextSelectedIndex].value;
            }
            // Remove the option
            select.removeChild(selectedOption);
            // Select the next available option if there is one
            if (nextSelectedIndex >= 0) {
                select.selectedIndex = nextSelectedIndex;
                previousValue = nextValue;
                // Trigger onSelectChange
                if (options.onSelectChange) {
                    await options.onSelectChange(deletedValue, nextValue);
                }
            }
            else {
                // No options left, trigger onSelectChange with undefined as new value
                if (options.onSelectChange) {
                    await options.onSelectChange(deletedValue, undefined);
                }
                previousValue = undefined;
            }
            // Run after delete hook
            if (options.delete?.onAfterDelete) {
                await options.delete.onAfterDelete(deletedValue);
            }
        });
        container.appendChild(deleteButton);
    }
    return {
        select,
        container,
    };
}
//# sourceMappingURL=preset-select.js.map

/***/ }),

/***/ "./node_modules/sillytavern-utils-lib/dist/prompt-builder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/prompt-builder.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPrompt: () => (/* binding */ buildPrompt)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/sillytavern-utils-lib/dist/config.js");

/**
 * Builds chat prompt. Don't expect a perfect chat prompt like ST. But I would give guarantee that it will cover 98% of the cases.
 *
 * Token calculation is crippled. We only calculating tokens for the chat history. For example, If your max context is 16k, total token will be 16k + world info, author note, extensionPrompts, etc. Better than nothing.
 * @param targetMessageIndex - Last message index to include in prompt
 * @param [param1={}] - Options
 */
async function buildPrompt(api, targetMessageIndex, { presetName, instructName, contextName, syspromptName, maxContext } = {}) {
    if (!api) {
        throw new Error('API is required');
    }
    if (!['textgenerationwebui', 'openai'].includes(api)) {
        throw new Error('Unsupported API');
    }
    const context = SillyTavern.getContext();
    let messages = [];
    let { description, personality, persona, scenario, mesExamples, system, jailbreak } = context.getCharacterCardFields();
    const instructPreset = api === 'textgenerationwebui'
        ? context.getPresetManager('instruct')?.getCompletionPresetByName(instructName)
        : undefined;
    const isInstruct = !!instructPreset?.enabled;
    let mesExamplesArray = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_parseMesExamples)(mesExamples, isInstruct);
    function getMaxContext() {
        if (typeof maxContext === 'number') {
            return maxContext;
        }
        if (!maxContext) {
            return (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
        }
        if (maxContext === 'active' || !presetName) {
            return (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
        }
        if (typeof maxContext === 'number') {
            return maxContext;
        }
        let response;
        if (api === 'textgenerationwebui') {
            const preset = context.getPresetManager('textgenerationwebui')?.getCompletionPresetByName(presetName);
            response = preset?.max_length;
        }
        else {
            const preset = context.getPresetManager('openai')?.getCompletionPresetByName(presetName);
            response = preset?.openai_max_context;
        }
        return typeof response === 'number' ? response : (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
    }
    const currentMaxContext = getMaxContext();
    if (currentMaxContext <= 0) {
        return [];
    }
    const canUseTools = context.ToolManager.isToolCallingSupported();
    let coreChat = context.chat
        .slice(0, targetMessageIndex ? targetMessageIndex + 1 : undefined)
        .filter((x) => !x.is_system || (canUseTools && Array.isArray(x.extra?.tool_invocations)));
    coreChat = await Promise.all(coreChat.map(async (chatItem, index) => {
        let message = chatItem.mes;
        let regexType = chatItem.is_user ? _config_js__WEBPACK_IMPORTED_MODULE_0__.regex_placement.USER_INPUT : _config_js__WEBPACK_IMPORTED_MODULE_0__.regex_placement.AI_OUTPUT;
        const isContinue = false;
        let options = { isPrompt: true, depth: coreChat.length - index - (isContinue ? 2 : 1) };
        let regexedMessage = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getRegexedString)(message, regexType, options);
        regexedMessage = await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_appendFileContent)(chatItem, regexedMessage);
        if (chatItem?.extra?.append_title && chatItem?.extra?.title) {
            regexedMessage = `${regexedMessage}\n\n${chatItem.extra.title}`;
        }
        return {
            ...chatItem,
            mes: regexedMessage,
            index,
        };
    }));
    const chatForWI = coreChat.map((x) => (_config_js__WEBPACK_IMPORTED_MODULE_0__.world_info_include_names ? `${x.name}: ${x.mes}` : x.mes)).reverse();
    const { worldInfoString, worldInfoBefore, worldInfoAfter, worldInfoExamples, worldInfoDepth, anBefore, anAfter } = await context.getWorldInfoPrompt(chatForWI, currentMaxContext, false);
    // Add message example WI
    for (const example of worldInfoExamples) {
        const exampleMessage = example.content;
        if (exampleMessage.length === 0) {
            continue;
        }
        const formattedExample = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(exampleMessage, _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2);
        const cleanedExample = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_parseMesExamples)(formattedExample, isInstruct);
        // Insert depending on before or after position
        if (example.position === _config_js__WEBPACK_IMPORTED_MODULE_0__.wi_anchor_position.before) {
            mesExamplesArray.unshift(...cleanedExample);
        }
        else {
            mesExamplesArray.push(...cleanedExample);
        }
    }
    const textCompletion = api === 'textgenerationwebui';
    if (textCompletion) {
        // At this point, the raw message examples can be created
        const mesExamplesRawArray = [...mesExamplesArray];
        if (mesExamplesArray) {
            mesExamplesArray = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatInstructModeExamples)(mesExamplesArray, _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2);
        }
        const syspromptPreset = context.getPresetManager('sysprompt')?.getCompletionPresetByName(syspromptName);
        if (syspromptPreset) {
            system =
                context.powerUserSettings.prefer_character_prompt && system
                    ? system
                    : (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(syspromptPreset.content, _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2);
            system = isInstruct
                ? (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatInstructModeSystemPrompt)(context.substituteParams(system, _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2, syspromptPreset.content), instructPreset)
                : system;
        }
        // Build story string
        const storyStringParams = {
            description: description,
            personality: personality,
            persona: context.powerUserSettings.persona_description_position == _config_js__WEBPACK_IMPORTED_MODULE_0__.persona_description_positions.IN_PROMPT
                ? persona
                : '',
            scenario: scenario,
            system: system,
            char: _config_js__WEBPACK_IMPORTED_MODULE_0__.name2,
            user: _config_js__WEBPACK_IMPORTED_MODULE_0__.name1,
            wiBefore: worldInfoBefore,
            wiAfter: worldInfoAfter,
            loreBefore: worldInfoBefore,
            loreAfter: worldInfoAfter,
            mesExamples: mesExamplesArray.join(''),
            mesExamplesRaw: mesExamplesRawArray.join(''),
        };
        const contextPreset = context.getPresetManager('context')?.getCompletionPresetByName(contextName);
        let storyString = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_renderStoryString)(storyStringParams, {
            customInstructSettings: instructPreset,
            customStoryString: contextPreset?.story_string,
        });
        messages.push({ role: 'system', content: storyString, ignoreInstruct: true });
        // Add messages starting from most recent to respect context limits
        let currentTokenCount = 0;
        const chatMessages = [];
        for (let i = coreChat.length - 1; i >= 0; i--) {
            const message = coreChat[i];
            // Skip if adding this message would exceed context
            if (message.extra?.token_count && currentTokenCount + message.extra.token_count > currentMaxContext) {
                break;
            }
            currentTokenCount += message.extra?.token_count || 0;
            chatMessages.unshift({
                role: message.is_user ? 'user' : 'assistant',
                content: message.mes,
            });
        }
        messages.push(...chatMessages);
    }
    else {
        let oaiMessages = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_setOpenAIMessages)(coreChat);
        let oaiMessageExamples = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_setOpenAIMessageExamples)(mesExamplesArray);
        async function addDefaultPreset() {
            let [prompt, _counts] = await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_prepareOpenAIMessages)({
                name2: _config_js__WEBPACK_IMPORTED_MODULE_0__.name2,
                charDescription: description,
                charPersonality: personality,
                Scenario: scenario,
                worldInfoBefore: worldInfoBefore,
                worldInfoAfter: worldInfoAfter,
                extensionPrompts: context.extensionPrompts,
                bias: '',
                type: 'normal',
                quietPrompt: undefined,
                quietImage: undefined,
                cyclePrompt: '',
                systemPromptOverride: system,
                jailbreakPromptOverride: jailbreak,
                personaDescription: persona,
                messages: oaiMessages,
                messageExamples: oaiMessageExamples,
            }, false);
            messages.push(...prompt);
        }
        if (!presetName) {
            await addDefaultPreset();
            return messages;
        }
        const preset = context.getPresetManager('openai')?.getCompletionPresetByName(presetName);
        if (!preset) {
            console.warn(`Preset not found: ${presetName}. Using current preset.`);
            addDefaultPreset();
            return messages;
        }
        let promptOrder = preset.prompt_order.find((prompt) => prompt.character_id === _config_js__WEBPACK_IMPORTED_MODULE_0__.this_chid);
        if (!promptOrder && preset.prompt_order.length > 0) {
            promptOrder = preset.prompt_order[0];
        }
        if (!promptOrder) {
            console.warn(`No prompt order found for preset: ${presetName}. Using current preset.`);
            addDefaultPreset();
            return messages;
        }
        const scenarioText = scenario && preset.scenario_format ? context.substituteParams(preset.scenario_format) : '';
        const charPersonalityText = personality && preset.personality_format ? context.substituteParams(preset.personality_format) : '';
        const groupNudge = context.substituteParams(preset.group_nudge_prompt);
        const impersonationPrompt = preset.impersonation_prompt
            ? context.substituteParams(preset.impersonation_prompt)
            : '';
        // Create entries for system prompts
        const systemPrompts = [
            // Ordered prompts for which a marker should exist
            {
                role: 'system',
                content: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatWorldInfo)(worldInfoBefore, { wiFormat: preset.wi_format }),
                identifier: 'worldInfoBefore',
            },
            {
                role: 'system',
                content: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatWorldInfo)(worldInfoAfter, { wiFormat: preset.wi_format }),
                identifier: 'worldInfoAfter',
            },
            { role: 'system', content: description, identifier: 'charDescription' },
            { role: 'system', content: charPersonalityText, identifier: 'charPersonality' },
            { role: 'system', content: scenarioText, identifier: 'scenario' },
            // Unordered prompts without marker
            { role: 'system', content: impersonationPrompt, identifier: 'impersonate' },
            { role: 'system', content: groupNudge, identifier: 'groupNudge' },
        ];
        // Tavern Extras - Summary
        const summary = context.extensionPrompts['1_memory'];
        if (summary && summary.value)
            systemPrompts.push({
                role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(summary.role),
                content: summary.value,
                identifier: 'summary',
                position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(summary.position),
            });
        // Authors Note
        const authorsNote = context.extensionPrompts['2_floating_prompt'];
        if (authorsNote && authorsNote.value)
            systemPrompts.push({
                role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(authorsNote.role),
                content: authorsNote.value,
                identifier: 'authorsNote',
                position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(authorsNote.position),
            });
        // Vectors Memory
        const vectorsMemory = context.extensionPrompts['3_vectors'];
        if (vectorsMemory && vectorsMemory.value)
            systemPrompts.push({
                role: 'system',
                content: vectorsMemory.value,
                identifier: 'vectorsMemory',
                position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(vectorsMemory.position),
            });
        const vectorsDataBank = context.extensionPrompts['4_vectors_data_bank'];
        if (vectorsDataBank && vectorsDataBank.value)
            systemPrompts.push({
                role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(vectorsDataBank.role),
                content: vectorsDataBank.value,
                identifier: 'vectorsDataBank',
                position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(vectorsDataBank.position),
            });
        // Smart Context (ChromaDB)
        const smartContext = context.extensionPrompts['chromadb'];
        if (smartContext && smartContext.value)
            systemPrompts.push({
                role: 'system',
                content: smartContext.value,
                identifier: 'smartContext',
                position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(smartContext.position),
            });
        // Persona Description
        if (context.powerUserSettings.persona_description &&
            context.powerUserSettings.persona_description_position === _config_js__WEBPACK_IMPORTED_MODULE_0__.persona_description_positions.IN_PROMPT) {
            systemPrompts.push({
                role: 'system',
                content: context.powerUserSettings.persona_description,
                identifier: 'personaDescription',
            });
        }
        function getPrompt(identifier) {
            return systemPrompts.find((prompt) => prompt.identifier === identifier);
        }
        promptOrder.order.forEach((prompt) => {
            if (!prompt.enabled) {
                return;
            }
            const collectionPrompt = getPrompt(prompt.identifier);
            if (collectionPrompt && collectionPrompt.content) {
                messages.push({
                    role: collectionPrompt.role ?? 'system',
                    content: context.substituteParams(collectionPrompt.content),
                });
                return;
            }
            if (prompt.identifier === 'chatHistory') {
                // Add messages starting from most recent to respect context limits
                let currentTokenCount = 0;
                const chatMessages = [];
                for (let i = coreChat.length - 1; i >= 0; i--) {
                    const message = coreChat[i];
                    // Skip if adding this message would exceed context
                    if (message.extra?.token_count && currentTokenCount + message.extra.token_count > currentMaxContext) {
                        break;
                    }
                    currentTokenCount += message.extra?.token_count || 0;
                    chatMessages.unshift({
                        role: message.is_user ? 'user' : 'assistant',
                        content: message.mes,
                    });
                }
                messages.push(...chatMessages);
            }
        });
    }
    const knownExtensionPrompts = [
        '1_memory',
        '2_floating_prompt',
        '3_vectors',
        '4_vectors_data_bank',
        'chromadb',
        'PERSONA_DESCRIPTION',
        'QUIET_PROMPT',
        'DEPTH_PROMPT',
    ];
    // Anything that is not a known extension prompt
    for (const key in context.extensionPrompts) {
        if (Object.hasOwn(context.extensionPrompts, key)) {
            const prompt = context.extensionPrompts[key];
            if (knownExtensionPrompts.includes(key))
                continue;
            if (!context.extensionPrompts[key].value)
                continue;
            if (![_config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.BEFORE_PROMPT, _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.IN_PROMPT].includes(prompt.position))
                continue;
            const hasFilter = typeof prompt.filter === 'function';
            if (hasFilter && !(await prompt.filter()))
                continue;
            if (prompt.position === _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.BEFORE_PROMPT) {
                messages = [
                    ...messages.slice(0, prompt.depth),
                    {
                        role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(prompt.role) ?? 'system',
                        content: prompt.value,
                    },
                    ...messages.slice(prompt.depth),
                ];
            }
            else if (prompt.position === _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.IN_PROMPT) {
                messages = [
                    ...messages.slice(0, messages.length - prompt.depth),
                    {
                        role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(prompt.role) ?? 'system',
                        content: prompt.value,
                    },
                    ...messages.slice(messages.length - prompt.depth),
                ];
            }
        }
    }
    // Inject world info depth.
    for (const worldInfo of worldInfoDepth) {
        messages = [
            ...messages.slice(0, messages.length - worldInfo.depth),
            { role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(worldInfo.role), content: worldInfo.entries.join('\n') },
            ...messages.slice(messages.length - worldInfo.depth),
        ];
    }
    const groupDepthPrompts = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getGroupDepthPrompts)(_config_js__WEBPACK_IMPORTED_MODULE_0__.selected_group, Number(_config_js__WEBPACK_IMPORTED_MODULE_0__.this_chid));
    if (_config_js__WEBPACK_IMPORTED_MODULE_0__.selected_group && Array.isArray(groupDepthPrompts) && groupDepthPrompts.length > 0) {
        groupDepthPrompts.forEach((value, index) => {
            messages = [
                ...messages.slice(0, messages.length - value.depth),
                { role: value.role, content: value.text },
                ...messages.slice(messages.length - value.depth),
            ];
        });
    }
    else {
        const depthPromptText = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(_config_js__WEBPACK_IMPORTED_MODULE_0__.characters[_config_js__WEBPACK_IMPORTED_MODULE_0__.this_chid]?.data?.extensions?.depth_prompt?.prompt?.trim(), _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2) || '';
        const depthPromptDepth = _config_js__WEBPACK_IMPORTED_MODULE_0__.depth_prompt_depth_default;
        const depthPromptRole = _config_js__WEBPACK_IMPORTED_MODULE_0__.characters[_config_js__WEBPACK_IMPORTED_MODULE_0__.this_chid]?.data?.extensions?.depth_prompt?.role ?? _config_js__WEBPACK_IMPORTED_MODULE_0__.depth_prompt_role_default;
        messages = [
            ...messages.slice(0, messages.length - depthPromptDepth),
            { role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(depthPromptRole), content: depthPromptText },
            ...messages.slice(messages.length - depthPromptDepth),
        ];
    }
    // TODO: We should respect interval and world info scanning
    const authorNote = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getAuthorNote)();
    let authorNoteIndex = -1;
    if (authorNote.prompt) {
        authorNote.prompt = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(authorNote.prompt, _config_js__WEBPACK_IMPORTED_MODULE_0__.name1, _config_js__WEBPACK_IMPORTED_MODULE_0__.name2);
        switch (authorNote.position) {
            case _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.IN_PROMPT: // After first message
                messages = [...messages.slice(0, 1), { role: 'user', content: authorNote.prompt }, ...messages.slice(1)];
                authorNoteIndex = 1;
                break;
            case _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.IN_CHAT: // Depth + role in chat
                messages = [
                    ...messages.slice(0, messages.length - authorNote.depth),
                    { role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(authorNote.role), content: authorNote.prompt },
                    ...messages.slice(messages.length - authorNote.depth),
                ];
                authorNoteIndex = messages.length - authorNote.depth - 1;
                break;
            case _config_js__WEBPACK_IMPORTED_MODULE_0__.extension_prompt_types.BEFORE_PROMPT: // Before first message
                messages.unshift({ role: 'user', content: authorNote.prompt });
                authorNoteIndex = 0;
                break;
            default:
                break;
        }
    }
    // Add world info to author note
    if (authorNoteIndex >= 0) {
        if (anBefore.length > 0) {
            messages = [
                ...messages.slice(0, authorNoteIndex),
                { role: 'system', content: anBefore.join('\n') },
                ...messages.slice(authorNoteIndex),
            ];
            authorNoteIndex++;
        }
        if (anAfter.length > 0) {
            messages = [
                ...messages.slice(0, authorNoteIndex + 1),
                { role: 'system', content: anAfter.join('\n') },
                ...messages.slice(authorNoteIndex + 1),
            ];
        }
    }
    return messages;
}
//# sourceMappingURL=prompt-builder.js.map

/***/ }),

/***/ "./node_modules/sillytavern-utils-lib/dist/types/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/types/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventNames: () => (/* binding */ EventNames)
/* harmony export */ });
var EventNames;
(function (EventNames) {
    EventNames["APP_READY"] = "app_ready";
    EventNames["EXTRAS_CONNECTED"] = "extras_connected";
    EventNames["MESSAGE_SWIPED"] = "message_swiped";
    EventNames["MESSAGE_SENT"] = "message_sent";
    EventNames["MESSAGE_RECEIVED"] = "message_received";
    EventNames["MESSAGE_EDITED"] = "message_edited";
    EventNames["MESSAGE_DELETED"] = "message_deleted";
    EventNames["MESSAGE_UPDATED"] = "message_updated";
    EventNames["MESSAGE_FILE_EMBEDDED"] = "message_file_embedded";
    EventNames["MORE_MESSAGES_LOADED"] = "more_messages_loaded";
    EventNames["IMPERSONATE_READY"] = "impersonate_ready";
    EventNames["CHAT_CHANGED"] = "chat_id_changed";
    EventNames["GENERATION_AFTER_COMMANDS"] = "GENERATION_AFTER_COMMANDS";
    EventNames["GENERATION_STARTED"] = "generation_started";
    EventNames["GENERATION_STOPPED"] = "generation_stopped";
    EventNames["GENERATION_ENDED"] = "generation_ended";
    EventNames["EXTENSIONS_FIRST_LOAD"] = "extensions_first_load";
    EventNames["EXTENSION_SETTINGS_LOADED"] = "extension_settings_loaded";
    EventNames["SETTINGS_LOADED"] = "settings_loaded";
    EventNames["SETTINGS_UPDATED"] = "settings_updated";
    EventNames["GROUP_UPDATED"] = "group_updated";
    EventNames["MOVABLE_PANELS_RESET"] = "movable_panels_reset";
    EventNames["SETTINGS_LOADED_BEFORE"] = "settings_loaded_before";
    EventNames["SETTINGS_LOADED_AFTER"] = "settings_loaded_after";
    EventNames["CHATCOMPLETION_SOURCE_CHANGED"] = "chatcompletion_source_changed";
    EventNames["CHATCOMPLETION_MODEL_CHANGED"] = "chatcompletion_model_changed";
    EventNames["OAI_PRESET_CHANGED_BEFORE"] = "oai_preset_changed_before";
    EventNames["OAI_PRESET_CHANGED_AFTER"] = "oai_preset_changed_after";
    EventNames["OAI_PRESET_EXPORT_READY"] = "oai_preset_export_ready";
    EventNames["OAI_PRESET_IMPORT_READY"] = "oai_preset_import_ready";
    EventNames["WORLDINFO_SETTINGS_UPDATED"] = "worldinfo_settings_updated";
    EventNames["WORLDINFO_UPDATED"] = "worldinfo_updated";
    EventNames["CHARACTER_EDITED"] = "character_edited";
    EventNames["CHARACTER_PAGE_LOADED"] = "character_page_loaded";
    EventNames["CHARACTER_GROUP_OVERLAY_STATE_CHANGE_BEFORE"] = "character_group_overlay_state_change_before";
    EventNames["CHARACTER_GROUP_OVERLAY_STATE_CHANGE_AFTER"] = "character_group_overlay_state_change_after";
    EventNames["USER_MESSAGE_RENDERED"] = "user_message_rendered";
    EventNames["CHARACTER_MESSAGE_RENDERED"] = "character_message_rendered";
    EventNames["FORCE_SET_BACKGROUND"] = "force_set_background";
    EventNames["CHAT_DELETED"] = "chat_deleted";
    EventNames["CHAT_CREATED"] = "chat_created";
    EventNames["GROUP_CHAT_DELETED"] = "group_chat_deleted";
    EventNames["GROUP_CHAT_CREATED"] = "group_chat_created";
    EventNames["GENERATE_BEFORE_COMBINE_PROMPTS"] = "generate_before_combine_prompts";
    EventNames["GENERATE_AFTER_COMBINE_PROMPTS"] = "generate_after_combine_prompts";
    EventNames["GENERATE_AFTER_DATA"] = "generate_after_data";
    EventNames["GROUP_MEMBER_DRAFTED"] = "group_member_drafted";
    EventNames["WORLD_INFO_ACTIVATED"] = "world_info_activated";
    EventNames["TEXT_COMPLETION_SETTINGS_READY"] = "text_completion_settings_ready";
    EventNames["CHAT_COMPLETION_SETTINGS_READY"] = "chat_completion_settings_ready";
    EventNames["CHAT_COMPLETION_PROMPT_READY"] = "chat_completion_prompt_ready";
    EventNames["CHARACTER_FIRST_MESSAGE_SELECTED"] = "character_first_message_selected";
    // TODO: Naming convention is inconsistent with other events
    EventNames["CHARACTER_DELETED"] = "characterDeleted";
    EventNames["CHARACTER_DUPLICATED"] = "character_duplicated";
    EventNames["CHARACTER_RENAMED"] = "character_renamed";
    /** @deprecated The event is aliased to STREAM_TOKEN_RECEIVED. */
    EventNames["SMOOTH_STREAM_TOKEN_RECEIVED"] = "stream_token_received";
    EventNames["STREAM_TOKEN_RECEIVED"] = "stream_token_received";
    EventNames["STREAM_REASONING_DONE"] = "stream_reasoning_done";
    EventNames["FILE_ATTACHMENT_DELETED"] = "file_attachment_deleted";
    EventNames["WORLDINFO_FORCE_ACTIVATE"] = "worldinfo_force_activate";
    EventNames["OPEN_CHARACTER_LIBRARY"] = "open_character_library";
    EventNames["ONLINE_STATUS_CHANGED"] = "online_status_changed";
    EventNames["IMAGE_SWIPED"] = "image_swiped";
    EventNames["CONNECTION_PROFILE_LOADED"] = "connection_profile_loaded";
    EventNames["TOOL_CALLS_PERFORMED"] = "tool_calls_performed";
    EventNames["TOOL_CALLS_RENDERED"] = "tool_calls_rendered";
})(EventNames || (EventNames = {}));
//# sourceMappingURL=index.js.map

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/


function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var prompt_builder_1 = __webpack_require__(/*! sillytavern-utils-lib/prompt-builder */ "./node_modules/sillytavern-utils-lib/dist/prompt-builder.js");
var preset_select_1 = __webpack_require__(/*! sillytavern-utils-lib/preset-select */ "./node_modules/sillytavern-utils-lib/dist/preset-select.js");
var config_1 = __webpack_require__(/*! sillytavern-utils-lib/config */ "./node_modules/sillytavern-utils-lib/dist/config.js");
var types_1 = __webpack_require__(/*! sillytavern-utils-lib/types */ "./node_modules/sillytavern-utils-lib/dist/types/index.js");
var extensionName = 'SillyTavern-Roadway';
var globalContext = SillyTavern.getContext();
var EXTRA_TARGET_KEY = 'roadway_target_chat';
var EXTRA_RAW_CONTENT_KEY = 'roadway_raw_content';
var EXTRA_OPTIONS_KEY = 'roadway_options';
var EXTENSION_SETTINGS_KEY = 'roadway';
function getExtensionSettings() {
  var context = SillyTavern.getContext();
  return context.extensionSettings[EXTENSION_SETTINGS_KEY];
}
var DEFAULT_IMPERSONATE = "Your task this time is to write your response as if you were {{user}}, impersonating their style. Use {{user}}'s dialogue and actions so far as a guideline for how they would likely act. Don't ever write as {{char}}. Only talk and act as {{user}}. This is what {{user}}'s focus:\n\n{{roadwaySelected}}";
var DEFAULT_PROMPT = "You are an AI brainstorming partner, helping to create immersive and surprising roleplaying experiences. Given the following context, your task is to generate an *unpredictable* and *engaging* list of options for the player.\n\nOutput ONLY a numbered list of possible actions. Each action should be a clear, actionable, concise, and *creative* sentence written in plain text.\n\nPrioritize *varied* actions that span multiple domains:\n\n{Observation/Investigation; Dialogue/Persuasion; Stealth/Intrigue; Combat/Conflict; Crafting/Repair; Knowledge/Lore; Movement/Traversal; Deception/Manipulation; Performance/Entertainment; Technical/Mechanical}.\n\nAvoid obvious or repetitive actions. Push the boundaries of the situation. Challenge the player's expectations. Do not include greetings, farewells, polite thanks, or options that break character. Generate *exactly* 10 actions. The actions must be written in plain text.\n\nHere are a few example actions to inspire creativity:\n\n1. Attempt to communicate with the forest creatures to learn the location of hidden trails.\n2. Bribe the corrupt city guard with a song and a dance.\n3. Stage a fake ambush to draw out a hidden enemy.";
var DEFAULT_SETTINGS = {
  profileId: '',
  maxContextType: 'profile',
  maxContextValue: 16384,
  maxResponseToken: 500,
  promptPreset: 'default',
  promptPresets: {
    "default": {
      content: DEFAULT_PROMPT,
      extractionStrategy: 'bullet',
      impersonate: DEFAULT_IMPERSONATE
    }
  }
};
function initializeDefaultSettings() {
  var _globalContext$extens;
  globalContext.extensionSettings[EXTENSION_SETTINGS_KEY] = ((_globalContext$extens = globalContext.extensionSettings) === null || _globalContext$extens === void 0 ? void 0 : _globalContext$extens[EXTENSION_SETTINGS_KEY]) || {};
  function initializeRecursively(target, defaults) {
    var anyChange = false;
    for (var _i = 0, _Object$keys = Object.keys(defaults); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (target[key] === undefined) {
        target[key] = defaults[key];
        anyChange = true;
      } else if (_typeof(defaults[key]) === 'object' && defaults[key] !== null) {
        target[key] = target[key] || {};
        if (initializeRecursively(target[key], defaults[key])) {
          anyChange = true;
        }
      }
    }
    return anyChange;
  }
  if (initializeRecursively(globalContext.extensionSettings[EXTENSION_SETTINGS_KEY], DEFAULT_SETTINGS)) {
    globalContext.saveSettingsDebounced();
  }
}
function handleUIChanges() {
  return _handleUIChanges.apply(this, arguments);
}
function _handleUIChanges() {
  _handleUIChanges = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    var _settings$promptPrese8;
    var settingsHtml, settingsContainer, settings, _ref3, select, promptElement, extractionStrategyElement, impersonateSection, impersonateElement, updateExtractionStrategy, maxContextTypeElement, maxContextValueElement, maxContextCustomDiv, maxResponseTokenElement, roadwayButton, pendingRequests, formatResponse;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          formatResponse = function _formatResponse(response, options) {
            var classPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
            var detailsElement = document.createElement('details');
            var summaryElement = document.createElement('summary');
            summaryElement.textContent = 'Roadway';
            detailsElement.appendChild(summaryElement);
            if (options !== null && options !== void 0 && options.length) {
              var optionsDiv = document.createElement('div');
              optionsDiv.classList.add("".concat(classPrefix, "roadway_options"));
              options.forEach(function (option, index) {
                var optionDiv = document.createElement('div');
                optionDiv.classList.add("".concat(classPrefix, "roadway_option"));
                var contentDiv = document.createElement('div');
                contentDiv.classList.add("".concat(classPrefix, "option_content"));
                contentDiv.textContent = option;
                var actionsDiv = document.createElement('div');
                actionsDiv.classList.add("".concat(classPrefix, "option_actions"));
                // Create impersonate button
                var impersonateButton = document.createElement('div');
                impersonateButton.classList.add("".concat(classPrefix, "action_button"), "".concat(classPrefix, "impersonate_action"));
                impersonateButton.innerHTML = '';
                impersonateButton.title = 'Impersonate';
                // Create edit button
                var editButton = document.createElement('div');
                editButton.classList.add("".concat(classPrefix, "action_button"), "".concat(classPrefix, "edit_action"));
                editButton.innerHTML = '';
                editButton.title = 'Edit';
                actionsDiv.appendChild(impersonateButton);
                actionsDiv.appendChild(editButton);
                optionDiv.appendChild(contentDiv);
                optionDiv.appendChild(actionsDiv);
                optionsDiv.appendChild(optionDiv);
              });
              detailsElement.appendChild(optionsDiv);
            } else {
              var preElement = document.createElement('pre');
              preElement.classList.add("".concat(classPrefix, "roadway_pre"));
              preElement.textContent = response;
              detailsElement.appendChild(preElement);
            }
            return detailsElement.outerHTML;
          };
          updateExtractionStrategy = function _updateExtractionStra() {
            var settings = getExtensionSettings();
            var preset = settings.promptPresets[settings.promptPreset];
            extractionStrategyElement.val(preset === null || preset === void 0 ? void 0 : preset.extractionStrategy);
            var isNone = (preset === null || preset === void 0 ? void 0 : preset.extractionStrategy) === 'none';
            impersonateSection.toggle(!isNone);
            impersonateElement.val((preset === null || preset === void 0 ? void 0 : preset.impersonate) || '');
          };
          _context6.next = 4;
          return globalContext.renderExtensionTemplateAsync("third-party/".concat(extensionName), 'templates/settings');
        case 4:
          settingsHtml = _context6.sent;
          $('#extensions_settings').append(settingsHtml);
          settingsContainer = $('.roadway_settings');
          globalContext.ConnectionManagerRequestService.handleDropdown('.roadway_settings .connection_profile', getExtensionSettings().profileId, function (profile) {
            var context = SillyTavern.getContext();
            var settings = getExtensionSettings();
            settings.profileId = profile ? profile.id : '';
            context.saveSettingsDebounced();
          });
          settings = getExtensionSettings();
          _ref3 = (0, preset_select_1.buildPresetSelect)('.roadway_settings select.prompt', {
            label: 'prompt',
            initialValue: settings.promptPreset,
            initialList: Object.keys(settings.promptPresets),
            readOnlyValues: ['default'],
            onSelectChange: function () {
              var _onSelectChange = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(previousValue, newValue) {
                var _settings$promptPrese, _settings$promptPrese2, _settings$promptPrese3, _settings$promptPrese4;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      settings = getExtensionSettings();
                      settings.promptPreset = newValue !== null && newValue !== void 0 ? newValue : 'default';
                      promptElement.val(((_settings$promptPrese = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese === void 0 ? void 0 : _settings$promptPrese.content) || '');
                      extractionStrategyElement.val((_settings$promptPrese2 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese2 === void 0 ? void 0 : _settings$promptPrese2.extractionStrategy);
                      impersonateElement.val(((_settings$promptPrese3 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese3 === void 0 ? void 0 : _settings$promptPrese3.impersonate) || '');
                      impersonateSection.css('display', ((_settings$promptPrese4 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese4 === void 0 ? void 0 : _settings$promptPrese4.extractionStrategy) === 'none' ? 'none' : 'block');
                      globalContext.saveSettingsDebounced();
                    case 7:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              function onSelectChange(_x, _x2) {
                return _onSelectChange.apply(this, arguments);
              }
              return onSelectChange;
            }(),
            create: {
              onAfterCreate: function onAfterCreate(value) {
                var _settings$promptPrese5, _settings$promptPrese6, _settings$promptPrese7;
                settings = getExtensionSettings();
                settings.promptPresets[value] = {
                  content: ((_settings$promptPrese5 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese5 === void 0 ? void 0 : _settings$promptPrese5.content) || DEFAULT_PROMPT,
                  extractionStrategy: ((_settings$promptPrese6 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese6 === void 0 ? void 0 : _settings$promptPrese6.extractionStrategy) || 'bullet',
                  impersonate: ((_settings$promptPrese7 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese7 === void 0 ? void 0 : _settings$promptPrese7.impersonate) || DEFAULT_IMPERSONATE
                };
                globalContext.saveSettingsDebounced();
              }
            },
            rename: {
              onAfterRename: function onAfterRename(previousValue, newValue) {
                settings = getExtensionSettings();
                settings.promptPresets[newValue] = settings.promptPresets[previousValue];
                delete settings.promptPresets[previousValue];
                globalContext.saveSettingsDebounced();
              }
            },
            "delete": {
              onAfterDelete: function onAfterDelete(value) {
                settings = getExtensionSettings();
                delete settings.promptPresets[value];
                globalContext.saveSettingsDebounced();
              }
            }
          }), select = _ref3.select;
          promptElement = settingsContainer.find('textarea.prompt');
          promptElement.val(((_settings$promptPrese8 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese8 === void 0 ? void 0 : _settings$promptPrese8.content) || '');
          promptElement.on('change', function () {
            settings = getExtensionSettings();
            var template = promptElement.val();
            settings.promptPresets[settings.promptPreset].content = template;
            globalContext.saveSettingsDebounced();
          });
          extractionStrategyElement = settingsContainer.find('select.extraction_strategy');
          impersonateSection = settingsContainer.find('.impersonate_section');
          impersonateElement = settingsContainer.find('textarea.impersonate');
          updateExtractionStrategy();
          extractionStrategyElement.on('change', function () {
            settings = getExtensionSettings();
            var value = $(this).val();
            settings.promptPresets[settings.promptPreset].extractionStrategy = value;
            var isNone = value === 'none';
            impersonateSection.toggle(!isNone);
            globalContext.saveSettingsDebounced();
          });
          impersonateElement.on('change', function () {
            settings = getExtensionSettings();
            settings.promptPresets[settings.promptPreset].impersonate = $(this).val();
            globalContext.saveSettingsDebounced();
          });
          // Update extraction strategy when preset changes
          select.addEventListener('change', updateExtractionStrategy);
          settingsContainer.find('.restore_default').on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
            var confirm, settings;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return globalContext.Popup.show.confirm('Are you sure you want to restore the default prompt?', 'Restore default');
                case 2:
                  confirm = _context4.sent;
                  if (confirm) {
                    _context4.next = 5;
                    break;
                  }
                  return _context4.abrupt("return");
                case 5:
                  settings = getExtensionSettings();
                  settings.promptPresets['default'].content = DEFAULT_PROMPT;
                  settings.promptPresets['default'].extractionStrategy = 'bullet';
                  settings.promptPresets['default'].impersonate = DEFAULT_IMPERSONATE;
                  promptElement.val(DEFAULT_PROMPT);
                  extractionStrategyElement.val('bullet');
                  impersonateElement.val(DEFAULT_IMPERSONATE);
                  if (select.value !== 'default') {
                    select.value = 'default';
                    select.dispatchEvent(new Event('change'));
                  } else {
                    globalContext.saveSettingsDebounced();
                  }
                case 13:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          })));
          maxContextTypeElement = settingsContainer.find('.max_context_type');
          maxContextValueElement = settingsContainer.find('.max_context_value');
          maxContextCustomDiv = settingsContainer.find('.max_context_custom');
          maxContextTypeElement.val(getExtensionSettings().maxContextType);
          maxContextValueElement.val(getExtensionSettings().maxContextValue);
          if (getExtensionSettings().maxContextType === 'custom') {
            maxContextCustomDiv.show();
          }
          maxContextTypeElement.on('change', function () {
            var context = SillyTavern.getContext();
            var settings = getExtensionSettings();
            var newType = $(this).val();
            settings.maxContextType = newType;
            maxContextCustomDiv.toggle(newType === 'custom');
            context.saveSettingsDebounced();
          });
          maxContextValueElement.on('change', function () {
            var context = SillyTavern.getContext();
            var settings = getExtensionSettings();
            settings.maxContextValue = Number($(this).val());
            context.saveSettingsDebounced();
          });
          maxResponseTokenElement = settingsContainer.find('.max_response_tokens');
          maxResponseTokenElement.val(getExtensionSettings().maxResponseToken);
          maxResponseTokenElement.on('change', function () {
            var context = SillyTavern.getContext();
            var settings = getExtensionSettings();
            settings.maxResponseToken = Number($(this).val());
            context.saveSettingsDebounced();
          });
          roadwayButton = $("<div title=\"Generate Roadway\" class=\"mes_button mes_magic_roadway_button fa-solid fa-road interactable\" tabindex=\"0\"></div>");
          $('#message_template .mes_buttons .extraMesButtons').prepend(roadwayButton);
          pendingRequests = new Set();
          $(document).on('click', '.mes_magic_roadway_button', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
            var _context$extensionSet;
            var context, settings, messageBlock, targetMessageId, profile, presetName, contextName, instructName, syspromptName, apiMap, _settings$promptPrese9, _actions, messages, rest, actions, extractionStrategy, innerText, existMessage, newMessage, _detailsElement, detailsElement;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  context = SillyTavern.getContext();
                  settings = getExtensionSettings();
                  if (settings.profileId) {
                    _context5.next = 6;
                    break;
                  }
                  _context5.next = 5;
                  return (0, config_1.st_echo)('error', 'Please select a connection profile first in the settings.');
                case 5:
                  return _context5.abrupt("return");
                case 6:
                  if (settings.promptPreset) {
                    _context5.next = 10;
                    break;
                  }
                  _context5.next = 9;
                  return (0, config_1.st_echo)('error', 'Please enter a prompt first in the settings.');
                case 9:
                  return _context5.abrupt("return");
                case 10:
                  messageBlock = $(this).closest('.mes');
                  targetMessageId = Number(messageBlock.attr('mesid'));
                  profile = (_context$extensionSet = context.extensionSettings.connectionManager) === null || _context$extensionSet === void 0 || (_context$extensionSet = _context$extensionSet.profiles) === null || _context$extensionSet === void 0 ? void 0 : _context$extensionSet.find(function (profile) {
                    return profile.id === settings.profileId;
                  });
                  presetName = profile === null || profile === void 0 ? void 0 : profile.preset;
                  contextName = profile === null || profile === void 0 ? void 0 : profile.context;
                  instructName = profile === null || profile === void 0 ? void 0 : profile.instruct;
                  syspromptName = profile === null || profile === void 0 ? void 0 : profile.sysprompt;
                  apiMap = profile !== null && profile !== void 0 && profile.api ? context.CONNECT_API_MAP[profile.api] : null;
                  _context5.prev = 18;
                  if (!pendingRequests.has(targetMessageId)) {
                    _context5.next = 23;
                    break;
                  }
                  _context5.next = 22;
                  return (0, config_1.st_echo)('warning', 'A request for this message is already in progress. Please wait.');
                case 22:
                  return _context5.abrupt("return");
                case 23:
                  pendingRequests.add(targetMessageId);
                  $(this).addClass('spinning');
                  _context5.next = 27;
                  return (0, prompt_builder_1.buildPrompt)(apiMap === null || apiMap === void 0 ? void 0 : apiMap.selected, targetMessageId, {
                    presetName: presetName,
                    contextName: contextName,
                    instructName: instructName,
                    syspromptName: syspromptName,
                    maxContext: settings.maxContextType === 'custom' ? settings.maxContextValue : settings.maxContextType === 'profile' ? 'preset' : 'active'
                  });
                case 27:
                  messages = _context5.sent;
                  messages.push({
                    content: context.substituteParams(settings.promptPresets[settings.promptPreset].content),
                    role: 'system'
                  });
                  _context5.next = 31;
                  return context.ConnectionManagerRequestService.sendRequest(settings.profileId, messages, settings.maxResponseToken);
                case 31:
                  rest = _context5.sent;
                  actions = [];
                  extractionStrategy = (_settings$promptPrese9 = settings.promptPresets[settings.promptPreset]) === null || _settings$promptPrese9 === void 0 ? void 0 : _settings$promptPrese9.extractionStrategy;
                  if (!(extractionStrategy === 'bullet')) {
                    _context5.next = 39;
                    break;
                  }
                  actions = extractBulletPoints(rest.content);
                  if (!(actions.length === 0)) {
                    _context5.next = 39;
                    break;
                  }
                  _context5.next = 39;
                  return (0, config_1.st_echo)('warning', 'Could not extract any bullet points from the response. Using original response.');
                case 39:
                  innerText = (_actions = actions) !== null && _actions !== void 0 && _actions.length ? actions.map(function (action, index) {
                    return "".concat(index + 1, ". ").concat(action);
                  }).join('\n') : rest.content;
                  existMessage = context.chat.find(function (mes) {
                    var _mes$extra;
                    return ((_mes$extra = mes.extra) === null || _mes$extra === void 0 ? void 0 : _mes$extra[EXTRA_TARGET_KEY]) === targetMessageId;
                  });
                  newMessage = existMessage !== null && existMessage !== void 0 ? existMessage : {
                    mes: formatResponse(innerText, extractionStrategy === 'bullet' ? actions : undefined),
                    name: config_1.systemUserName,
                    force_avatar: config_1.system_avatar,
                    is_system: true,
                    is_user: false,
                    extra: _defineProperty(_defineProperty(_defineProperty({
                      isSmallSys: true
                    }, EXTRA_TARGET_KEY, targetMessageId), EXTRA_RAW_CONTENT_KEY, innerText), EXTRA_OPTIONS_KEY, actions)
                  };
                  if (existMessage) {
                    newMessage.mes = formatResponse(innerText, extractionStrategy === 'bullet' ? actions : undefined);
                    newMessage.extra[EXTRA_RAW_CONTENT_KEY] = rest.content;
                    newMessage.extra[EXTRA_OPTIONS_KEY] = actions;
                    _detailsElement = $("[mesid=\"".concat(targetMessageId + 1, "\"] .mes_text"));
                    _detailsElement.html(formatResponse(innerText, extractionStrategy === 'bullet' ? actions : undefined, 'custom-'));
                  } else {
                    context.chat.push(newMessage);
                    context.addOneMessage(newMessage, {
                      insertAfter: targetMessageId
                    });
                  }
                  detailsElement = $("[mesid=\"".concat(targetMessageId + 1, "\"] .mes_text details"));
                  if (!detailsElement.attr('open')) {
                    detailsElement.attr('open', '');
                  }
                  attachRoadwayOptionHandlers(targetMessageId + 1);
                  _context5.next = 48;
                  return context.saveChat();
                case 48:
                  _context5.next = 55;
                  break;
                case 50:
                  _context5.prev = 50;
                  _context5.t0 = _context5["catch"](18);
                  console.error(_context5.t0);
                  _context5.next = 55;
                  return (0, config_1.st_echo)('error', "Error: ".concat(_context5.t0));
                case 55:
                  _context5.prev = 55;
                  pendingRequests["delete"](targetMessageId);
                  $('.mes_magic_roadway_button').removeClass('spinning');
                  return _context5.finish(55);
                case 59:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this, [[18, 50, 55, 59]]);
          })));
        case 36:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _handleUIChanges.apply(this, arguments);
}
function extractBulletPoints(text) {
  var matches = text.match(/^(?:\d+\.(?:\s+|(?=\S))|-\s+)(.*)$/gm) || [];
  return matches.map(function (line) {
    return line.replace(/^(?:\d+\.(?:\s+|(?=\S))|-\s+)/, '').trim();
  });
}
function attachRoadwayOptionHandlers(roadwayMessageId) {
  var optionsContainer = $("[mesid=\"".concat(roadwayMessageId, "\"] .custom-roadway_options"));
  optionsContainer.find('.custom-action_button').off();
  var context = SillyTavern.getContext();
  // Handle impersonate action
  optionsContainer.find('.custom-impersonate_action').on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _message$extra;
    var parentOption, index, message, preset, impersonate;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          parentOption = $(this).closest('.custom-roadway_option');
          index = optionsContainer.find('.custom-roadway_option').index(parentOption);
          message = context.chat.find(function (mes, index) {
            return roadwayMessageId === index;
          });
          if (message) {
            _context.next = 5;
            break;
          }
          return _context.abrupt("return");
        case 5:
          preset = getExtensionSettings().promptPresets[context.extensionSettings[EXTENSION_SETTINGS_KEY].promptPreset];
          if (!(!preset || !preset.impersonate)) {
            _context.next = 10;
            break;
          }
          _context.next = 9;
          return (0, config_1.st_echo)('error', 'Preset not found. Please check the extension settings.');
        case 9:
          return _context.abrupt("return");
        case 10:
          impersonate = context.substituteParams(preset.impersonate, undefined, undefined, undefined, undefined, undefined, {
            roadwaySelected: (_message$extra = message.extra) === null || _message$extra === void 0 || (_message$extra = _message$extra[EXTRA_OPTIONS_KEY]) === null || _message$extra === void 0 ? void 0 : _message$extra[index]
          }, undefined);
          (0, config_1.st_runCommandCallback)('impersonate', undefined, impersonate);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  })));
  // Handle edit action
  optionsContainer.find('.custom-edit_action').on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var parentOption, contentDiv, originalText, input;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          parentOption = $(this).closest('.custom-roadway_option');
          contentDiv = parentOption.find('.custom-option_content');
          originalText = contentDiv.text(); // Create input for editing
          input = $('<textarea>').val(originalText).css({
            width: '100%',
            minHeight: '50px',
            resize: 'vertical',
            backgroundColor: 'var(--SmartThemeBlurTintColor)',
            color: 'var(--SmartThemeBodyColor)',
            border: '1px solid var(--SmartThemeBorderColor)',
            borderRadius: 'var(--avatar-base-border-radius)',
            padding: 'calc(var(--mainFontSize) * 0.5)'
          });
          contentDiv.empty().append(input);
          input.trigger('focus');
          // Handle save on blur
          input.on('blur', function () {
            var _message$extra2;
            var newText = input.val();
            contentDiv.text(newText);
            // Update the stored options
            var message = context.chat.find(function (_mes, index) {
              return roadwayMessageId === index;
            });
            if (message !== null && message !== void 0 && (_message$extra2 = message.extra) !== null && _message$extra2 !== void 0 && _message$extra2[EXTRA_OPTIONS_KEY]) {
              var index = optionsContainer.find('.custom-roadway_option').index(parentOption);
              message.extra[EXTRA_OPTIONS_KEY][index] = newText;
              context.saveChat();
            }
          });
          // Handle save on enter (shift+enter for new line)
          input.on('keydown', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              input.trigger('blur');
            }
          });
        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2, this);
  })));
}
function initializeEvents() {
  // If last message is roadway, add event listener
  globalContext.eventSource.on(types_1.EventNames.CHAT_CHANGED, function () {
    var _lastMessage$extra;
    var context = SillyTavern.getContext();
    if (!context.chat.length) {
      return;
    }
    var lastMessage = context.chat[context.chat.length - 1];
    if (typeof ((_lastMessage$extra = lastMessage.extra) === null || _lastMessage$extra === void 0 ? void 0 : _lastMessage$extra[EXTRA_TARGET_KEY]) === 'number') {
      attachRoadwayOptionHandlers(context.chat.length - 1);
    }
  });
}
initializeDefaultSettings();
handleUIChanges();
initializeEvents();
})();

var __webpack_exports___esModule = __webpack_exports__.__esModule;
export { __webpack_exports___esModule as __esModule };

//# sourceMappingURL=index.js.map